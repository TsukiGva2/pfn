package pfn

import (
	"errors"
	"fmt"
	"log"
	"strings"
)

const ( // Atypes
	/*
		types used for defining function arguments
		tNormal is for named arguments
		ex:

		.f(|x,y|->(+ x y))

		in this example both x and y
		will be of type tNormal, and defined as

		x, y = args[0], args[1]

		on the function body.

		tCompare is for pattern matched arguments
		ex:

		.f(|0|->"undefined")

		in this example there are no names to the
		arguments to be bind to, so the arguments
		are compared against the specified literal instead,
		you would see this on the function body:

		if 0 != args[0]:
		raise UnmatchedError()

		where '0' is of type tCompare.

		tTypeAssertX is for type assertions, ex:

		.f(|<list>x|->(sum x))

		in this example 'x' must be of type 'list'
		the function body will look like this:

		x = args[0]
		if type(list) != type:
			raise Exception(...)
		if list != type(x):
			raise UnmatchedError(...)

		pretty weird, i know, the first if statement
		might seem useless, but it just checks if list
		is actually a type, to prevent nonsense like
		0 != type(x).

		a type assertion can have two forms, N and C
		where N is for Normal (as in tNormal) and C is
		for Compare (as in tCompare), both do two things
		1 - the type assertion; and
		2 - the assignment/matching.
	*/
	tNormal = iota
	tCompare
	tTypeAssertN
	tTypeAssertC
)

type argument struct {
	expr  string
	atype int
}

var (
	ident    int
	fns      = make(map[string]([]string))
	keywords = map[string]int{
		"end":   0,
		"when":  1,
		"while": 2,
		"loop":  3,
		"break": 4,
		"let":   5,
	}
	gextra     []parserFn
	cerrs      []string
	IgnoreExpr bool
)

type parserFn func() (string, error)

type Transpiler struct {
	current uint
	tokens  []Token
	Output  string
}

func (tp *Transpiler) start() {
	/*
		Initialize stuff and run
	*/

	ident = 0
	fns = make(map[string]([]string))

	tp.Output += "# this code was auto generated by pfn\n\n"

	tp.Output += "class UnmatchedError(Exception):\n\tpass\n\n"
	tp.Output += "class ArgcountError(Exception):\n\tpass\n\n"

	pfncall := "def __pfn_call(p, args):\n"
	pfncall += "	result=None\n"
	pfncall += "	broke=False\n"
	pfncall += "	for f in p:\n"
	pfncall += "		try:\n"
	pfncall += "			result=eval(f+'(*'+str(args)+')')\n"
	pfncall += "		except (UnmatchedError, ArgcountError):\n"
	pfncall += "			continue\n"
	pfncall += "		broke=True\n\n"
	pfncall += "		break\n"
	pfncall += "	if not broke:\n"
	pfncall += "		raise Exception('no matching function')\n\n"
	pfncall += "	return result\n"

	tp.Output += pfncall
	//tp.Output = fmt.Sprintf("broke=False\nfor f in [%v]:\n\ttry:\n\t\tf(%s)\n\texcept (UnmatchedError, ArgcountError):\n\t\tcontinue\n\tbroke=True\n\tbreak\n\nif not broke:\n\traise Exception('no matching function')\n")

	gextra = append(gextra, tp.py, tp.out, tp.fn, tp.loop, tp.when, tp.match, tp.variable, tp.expr, tp.class)

	tp.run()
}

func (tp *Transpiler) run() {
	out, err := tp.code(cEOF, "")

	if err != nil {
		panic(err)
	}

	tp.Output += out
}

func (tp *Transpiler) code(end int, alt string, extra ...parserFn) (string, error) {
	// (fn | var | expr)*

	var pfns []parserFn
	var output string

	old := gextra
	gextra = append(gextra, extra...)

	pfns = append(pfns, gextra...)

	for {
		tok := tp.ctoken()

		if tok.tokTy == end || tok.tokTy == cEOF || (tok.tokTy == cIdentifier && strings.Contains(alt, tok.lexeme)) {
			break
		}

		res, err := tp.findMatchingParserFn(pfns)

		if err != nil {
			return "", err
		}

		lines := strings.Split(res, "\n")

		for i := range lines {
			if !strings.HasPrefix(lines[i], "\t") {
				output += strings.Repeat("\t", ident) + lines[i] + "\n"
			} else {
				output += lines[i] + "\n"
			}
		}

		tp.advance(1)
	}

	gextra = old

	return output, nil
}

// parsing functions

func (tp *Transpiler) fn() (string, error) {
	// "." id "(" "|" (id ("," id)*)? "|" code ")"

	var fname string
	var code string
	var prefix string
	var args []argument

	tok := tp.ctoken()

	if tok.tokTy == cAt {
		prefix = "async "
		tp.advance(1)
	}

	tok = tp.ctoken()

	if tok.tokTy != cDot {
		return "", errors.New("not a function: no dot")
	}

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cIdentifier {
		return "", errors.New("not a function: no identifier")
	}

	fname = tok.lexeme

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cLparen {
		return "", errors.New("not a function: missing opening paren on arguments declaration")
	}

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cBOr {
		return "", errors.New("not a function: missing argument list")
	}

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cBOr {
		for {
			if tok.tokTy == cLt {
				tp.advance(1)
				tok = tp.ctoken()

				expr, err := tp.expr()

				if err != nil {
					return "", errors.New("not a function: invalid type assertion: couldn't parse type expression")
				}

				tp.advance(1)
				tok = tp.ctoken()

				if tok.tokTy != cGt {
					return "", errors.New("not a function: invalid type assertion")
				}

				tp.advance(1)
				tok = tp.ctoken()

				if tok.tokTy != cIdentifier {
					expr2, err := tp.expr()

					if err != nil {
						return "", errors.New("not a function: error parsing expr")
					}

					args = append(args, argument{expr2 + "|" + expr, tTypeAssertC})
					goto out
				}

				args = append(args, argument{tok.lexeme + "|" + expr, tTypeAssertN})
			} else if tok.tokTy != cIdentifier {
				expr, err := tp.expr()

				if err != nil {
					return "", errors.New("not a function: error parsing expr")
				}

				args = append(args, argument{expr, tCompare})
			} else {
				args = append(args, argument{tok.lexeme, tNormal})
			}
out:

			tp.advance(1)

			if tp.ctoken().tokTy != cComma {
				break
			}

			tp.advance(1)
			tok = tp.ctoken()
		}
	}

	tok = tp.ctoken()

	if tok.tokTy != cBOr {
		return "", errors.New("not a function: argument list not properly closed")
	}

	f, exists := fns[fname]
	oldName := fname

	if exists {
		fname = fmt.Sprintf("%s_%d", fname, len(f))
	}

	code = fmt.Sprintf("%sdef pfn_%s(*args):\n", prefix, fname)

	code += fmt.Sprintf("\tif len(args) < %d:\n\t\traise ArgcountError('too few arguments for function %s')\n", len(args), fname)

	for i := range args {
		arg := args[i]

		if arg.expr == "_" {
			continue
		}

		if arg.atype == tNormal {
			code += fmt.Sprintf("\t%s = args[%d]\n", arg.expr, i)
			continue
		}

		if arg.atype == tTypeAssertN {
			exp := arg.expr
			argname := exp[:strings.Index(exp, "|")]
			texpr := exp[strings.Index(exp, "|")+1:]

			code += fmt.Sprintf("\tif type(%s) != type:\n\t\traise Exception('type assertion expression must be a valid type')\n", texpr)
			code += fmt.Sprintf("\tif %s != type(args[%d]):\n\t\traise UnmatchedError('unmatched')\n", texpr, i)
			code += fmt.Sprintf("\t%s = args[%d]\n", argname, i)
			continue
		}

		if arg.atype == tTypeAssertC {
			exp := arg.expr
			cmp := exp[:strings.Index(exp, "|")]
			texpr := exp[strings.Index(exp, "|")+1:]

			code += fmt.Sprintf("\tif type(%s) != type:\n\t\traise Exception('type assertion expression must be a valid type')\n", texpr)
			code += fmt.Sprintf("\tif %s != type(args[%d]):\n\t\traise UnmatchedError('unmatched')\n", texpr, i)
			code += fmt.Sprintf("\tif %s != args[%d]:\n\t\traise UnmatchedError('unmatched')\n", cmp, i)
			continue
		}

		code += fmt.Sprintf("\tif %s != args[%d]:\n\t\traise UnmatchedError('unmatched')\n", arg.expr, i)
	}

	tp.advance(1)

	ident++
	out, err := tp.code(cRparen, "", tp.ret)

	if err != nil {
		return "", err
	}

	code += out
	ident--

	if exists {
		fns[oldName] = append(f, fmt.Sprintf("pfn_%s", fname))
		return code, nil
	}

	fns[oldName] = []string{fmt.Sprintf("pfn_%s", fname)}
	return code, nil
}

func (tp *Transpiler) ret() (string, error) {
	// "->" expr

	var output string

	tok := tp.ctoken()

	if tok.tokTy != cArrow {
		return "", errors.New("not a return statement: no arrow")
	}

	tp.advance(1)
	tok = tp.ctoken()

	output += "return "
	expr, err := tp.expr()

	if err != nil {
		return "", errors.New("not a return statement: error parsing expression")
	}

	output += expr

	return output, nil
}

func (tp *Transpiler) variable() (string, error) {
	// id ":=" expr

	var output string
	old := tp.current
	tok := tp.ctoken()

	ind, err := tp.index()

	if err != nil {
		tp.current = old
		if tok.tokTy != cIdentifier {
			return "", errors.New("not a variable: no identifier/index expr")
		}
		ind = tok.lexeme
	}

	output += ind

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cAssignment {
		return "", errors.New("not a variable: no assignment happening at all")
	}

	tp.advance(1)

	expr, err := tp.expr()

	if err != nil {
		return "", errors.New("not a variable: error parsing expr")
	}

	output += "=" + expr

	return output, nil
}

func (tp *Transpiler) expr() (string, error) {
	// (call | literal)

	fns := []parserFn{tp.let, tp.py, tp.call, tp.index, tp.ewhen, tp.list, tp.literal}
	old := tp.current

	var max uint
	var probableCause string
	var tokenAtErr string

	for i := range fns {
		res, err := fns[i]()

		if err == nil {
			return res, nil
		}

		steps := tp.current - old
		if steps >= max {
			max = steps
			probableCause = err.Error()
			tokenAtErr = tp.ctoken().lexeme
		}

		tp.current = old
	}

	if tp.ctoken().lexeme == "" && tokenAtErr == "" {
		return "", errors.New("error parsing expr")
	}

	if !IgnoreExpr {
		tp.lerr("expr", "no matching (expr)pfn for tokens '"+tp.ctoken().lexeme+"' through '"+tokenAtErr+"'\nprobably because of this error: "+probableCause)
	}

	return "", errors.New("error parsing expr")
}

func (tp *Transpiler) list() (string, error) {
	// "'"? "<" (expr ("," expr)*)? ">"

	var t []string = []string{"[", "]"}
	var output string

	tok := tp.ctoken()

	if tok.tokTy != cLt && tok.tokTy != cQuot {
		return "", errors.New("not a list: no opening < or '<")
	}

	if tok.tokTy == cQuot {
		tp.advance(1)
		tok = tp.ctoken()

		if tok.tokTy != cLt {
			return "", errors.New("not a tuple: no < after quote")
		}

		t = []string{"(", ")"}
	}

	tp.advance(1)
	tok = tp.ctoken()

	output += t[0]

	if tok.tokTy != cGt {
		for {
			expr, err := tp.expr()

			if err != nil {
				return "", errors.New("not a list: error parsing items")
			}

			output += expr

			tp.advance(1)
			tok = tp.ctoken()

			if tok.tokTy != cComma {
				break
			}

			output += ","

			tp.advance(1)
		}
	}

	tok = tp.ctoken()

	if tok.tokTy != cGt {
		return "", errors.New("not a list: no closing >")
	}

	tp.advance(1)
	tok = tp.ctoken()

	output += t[1]

	if tok.tokTy == cEloop && tok.lexeme == "where" {
		tp.advance(1)
		tok = tp.ctoken()

		if tok.tokTy != cIdentifier {
			return "", errors.New("not a list: error in 'where' clause, no identifier, did you mean 'where _'?")
		}

		v := tok.lexeme

		tp.advance(1)
		tok = tp.ctoken()

		if tok.tokTy == cEqArrow {
			tp.advance(1)
			tok = tp.ctoken()

			expr, err := tp.expr()

			if err != nil {
				return "", errors.New("not a list: (in 'where' clause) error parsing expr")
			}

			output = "[" + output + " for " + v + " in " + expr + "]"
			return output, nil
		}

		if tok.tokTy != cAssignment {
			return "", errors.New("not a list: error in 'where' clause, no ':=' or '=>'")
		}

		tp.advance(1)
		tok = tp.ctoken()

		expr, err := tp.expr()

		if err != nil {
			return "", errors.New("not a list: (in 'where' clause) error parsing expr")
		}

		output = "[" + output + " for " + v + " in " + "[" + expr + "]" + "][0]"
		tp.advance(1)
	}

	tp.previous(1)

	return output, nil
}

func (tp *Transpiler) literal() (string, error) {
	// (number | string | identifier)

	tok := tp.ctoken()

	switch tok.tokTy {
	case cNumber:
		break
	case cString:
		return "\"" + tok.literal.(string) + "\"", nil
	case cFString:
		return "f\"" + tok.literal.(string) + "\"", nil
	case cIdentifier:
		f, exists := fns[tok.lexeme]

		if exists {
			return fmt.Sprintf("(lambda *args: __pfn_call([%s], args))", strings.Join(f, ",")), nil
		}

		_, exists = keywords[tok.lexeme]
		if exists {
			return "", errors.New("keyword '" + tok.lexeme + "' is not a valid literal")
		}
	case cMinus:
		tp.advance(1)
		lit, err := tp.literal()
		if err != nil {
			return "", errors.New("not a valid literal of any kind")
		}
		return "-" + lit, nil

	default:
		return "", errors.New("not a valid literal of any kind")
	}

	return tok.lexeme, nil
}

func (tp *Transpiler) call() (string, error) {
	// "(" id (expr ("," expr)*)? ")"

	var isOp bool
	var unary bool
	var prefix string
	var output string

	tok := tp.ctoken()

	if tok.tokTy == cT {
		prefix = "await "
		tp.advance(1)
	}

	tok = tp.ctoken()

	if tok.tokTy != cLparen {
		return "", errors.New("not a function call: no opening paren")
	}

	tp.advance(1)
	tok = tp.ctoken()

	switch tok.tokTy {
	case cPlus:
		fallthrough
	case cMinus:
		fallthrough
	case cStar:
		fallthrough
	case cDoubleEq:
		fallthrough
	case cBangEq:
		fallthrough
	case cGt:
		fallthrough
	case cLAnd:
		fallthrough
	case cLOr:
		fallthrough
	case cLt:
		fallthrough
	case cGtEq:
		fallthrough
	case cLtEq:
		fallthrough
	case cColon:
		fallthrough
	case cSlash:
		isOp = true

	case cIdentifier:
		switch tok.lexeme {
		case "not":
			unary = true
		default:
			isOp = false
		}

	default:
		return "", errors.New("not a function call: no operator")
	}

	if unary {
		op := tok.lexeme
		tp.advance(1)
		tok = tp.ctoken()

		expr, err := tp.expr()

		if err != nil {
			return "", errors.New("not a function call: error parsing expr")
		}

		tp.advance(1)
		tok = tp.ctoken()

		if tok.tokTy != cRparen {
			return "", errors.New("not a function call: no closing paren")
		}

		output = "(" + op + " " + expr + ")"

		return output, nil
	}

	if isOp {
		output += "("

		op := tok.lexeme
		tp.advance(1)
		tok = tp.ctoken()

		/*if tok.tokTy != cLparen {
			return "", errors.New("not a function call: missing opening paren")
		}*/

		//tp.advance(1)
		//tok = tp.ctoken()

		if tok.tokTy != cRparen {

			argcount := 0

			for {
				expr, err := tp.expr()

				if err != nil {
					return "", errors.New("not a function call: error parsing arguments")
				}

				output += expr
				argcount++

				tp.advance(1)
				tok = tp.ctoken()

				if tok.tokTy == cEOF {
					return "", errors.New("general error (in tp.call): unclosed (")
				}

				if tok.tokTy == cRparen {
					break
				}

				output += " " + op + " "
			}

			if argcount < 1 {
				return "", errors.New("not a function call: not enough arguments to function " + op)
			}

			tok = tp.ctoken()

			output += ")"

			return output, nil
		}

		return "", errors.New("not a function call: not enough arguments to function " + op)
	}

	fname := tok.lexeme
	var args string

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cRparen {
		for {
			expr, err := tp.expr()

			if err != nil {
				return "", errors.New("not a function call: error parsing arguments")
			}

			args += expr

			tp.advance(1)
			tok = tp.ctoken()

			if tok.tokTy == cEOF {
				return "", errors.New("general error (in tp.call): unclosed (")
			}

			if tok.tokTy == cRparen {
				break
			}

			args += ","
		}
	}

	tok = tp.ctoken()

	if tok.tokTy != cRparen {
		return "", errors.New("not a function call: missing closing )")
	}

	f, exists := fns[fname]

	if exists {
		list := ""
		for i := range f {
			list += "'" + f[i] + "'"
			if i < len(f)-1 {
				list += ","
			}
		}
		output = fmt.Sprintf(prefix+"__pfn_call([%s], [%s])", list, args)
		//output = fmt.Sprintf("broke=False\nfor f in [%v]:\n\ttry:\n\t\tf(%s)\n\texcept (UnmatchedError, ArgcountError):\n\t\tcontinue\n\tbroke=True\n\tbreak\n\nif not broke:\n\traise Exception('no matching function')\n", strings.Join(f, ","), args)

		return output, nil
	}

	output = fmt.Sprintf("%s(%s)", fname, args)

	return output, nil
}

func (tp *Transpiler) ewhen() (string, error) {
	// "when" expr "do" code "end"
	var output string
	tok := tp.ctoken()

	if tok.tokTy != cIdentifier || tok.lexeme != "use" {
		return "", errors.New("not a when expression: missing 'use'")
	}

	tp.advance(1)

	expr, err := tp.expr()

	if err != nil {
		return "", errors.New("not a when expr: error parsing expression")
	}

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cIdentifier || tok.lexeme != "when" {
		return "", errors.New("not a when expr: no 'when'")
	}

	tp.advance(1)

	output += expr + " if "

	expr, err = tp.expr()

	if err != nil {
		return "", errors.New("not a when expr: error parsing expression")
	}

	output += expr

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cIdentifier || tok.lexeme != "else" {
		tp.previous(1)
		return output, nil
	}

	tp.advance(1)
	tok = tp.ctoken()

	expr, err = tp.expr()

	if err != nil {
		return "", errors.New("not a when expr: error parsing expr")
	}

	output += " else " + expr

	return output, nil
}

func (tp *Transpiler) when() (string, error) {
	// "when" expr "do" code "end"
	var output string
	tok := tp.ctoken()

	if tok.tokTy != cIdentifier || tok.lexeme != "when" {
		return "", errors.New("not a when block: missing 'when'")
	}

	output += "if "

	tp.advance(1)

	expr, err := tp.expr()

	if err != nil {
		return "", errors.New("not a when block: error parsing expression")
	}

	output += expr

	tp.advance(1)
	tok = tp.ctoken()

	output += ":\n"

	if tok.tokTy != cIdentifier || tok.lexeme != "do" {
		return "", errors.New("not a when block: no 'do'")
	}

	tp.advance(1)

	ident++
	code, err := tp.code(cEnd, "else", tp.ret)
	if err != nil {
		return "", err
	}
	ident--

	output += code

	tok = tp.ctoken()

	if tok.tokTy == cIdentifier && tok.lexeme == "else" {
		output += "else"

		tp.advance(1)
		tok = tp.ctoken()

		output += ":\n"

		ident++
		code, err = tp.code(cEnd, "", tp.ret)
		if err != nil {
			return "", err
		}
		ident--

		output += code
	}

	return output, nil
}

func (tp *Transpiler) py() (string, error) {
	// "py" "{" any "}"
	var output string

	tok := tp.ctoken()

	if tok.tokTy != cIdentifier || tok.lexeme != "py" {
		return "", errors.New("not a python block: missing 'py' keyword")
	}

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cString {
		return "", errors.New("not a python block: missing string")
	}

	output += tok.literal.(string)

	return output, nil
}

func (tp *Transpiler) loop() (string, error) {
	// "loop" code "where" id ("," id)* ("=>"|":=") expr
	var output string
	var lvar string

	tok := tp.ctoken()

	if tok.tokTy != cIdentifier || tok.lexeme != "loop" {
		return "", errors.New("not a loop: no 'loop' keyword")
	}

	tp.advance(1)

	ident++
	code, err := tp.code(cEloop, "", tp.brk)
	if err != nil {
		return "", err
	}
	ident--

	tok = tp.ctoken()

	if tok.tokTy != cEloop || tok.lexeme != "where" {
		if tok.tokTy == cEloop && tok.lexeme == "while" {
			tp.advance(1)

			expr, err := tp.expr()

			if err != nil {
				return "", errors.New("not a loop: error parsing expr")
			}

			output = fmt.Sprintf("while %s:\n%s", expr, code)
			return output, nil
		}

		return "", errors.New("not a loop: no where or when")
	}

	tp.advance(1)
	tok = tp.ctoken()

	for {
		if tok.tokTy != cIdentifier {
			return "", errors.New("not a loop: no identifier after where or comma")
		}

		lvar += tok.lexeme

		tp.advance(1)
		tok = tp.ctoken()

		if tok.tokTy != cComma {
			break
		}

		lvar += ","

		tp.advance(1)
		tok = tp.ctoken()
	}

	if tok.tokTy == cAssignment {
		tp.advance(1)

		expr, err := tp.expr()

		if err != nil {
			return "", errors.New("not a loop: error parsing expr")
		}

		output = fmt.Sprintf("%s=%s\nwhile %s:\n%s", lvar, expr, lvar, code)
		return output, nil
	}

	if tok.tokTy != cEqArrow {
		return "", errors.New("not a loop: no '=>' or ':='")
	}

	tp.advance(1)
	tok = tp.ctoken()

	expr, err := tp.expr()

	if err != nil {
		return "", errors.New("not a loop: error parsing expr")
	}

	output = fmt.Sprintf("for %s in %s:\n%s", lvar, expr, code)

	return output, nil
}

func (tp *Transpiler) brk() (string, error) {
	tok := tp.ctoken()

	if tok.tokTy != cIdentifier || tok.lexeme != "break" {
		return "", errors.New("not break")
	}

	return "break", nil
}

func (tp *Transpiler) let() (string, error) {
	tok := tp.ctoken()

	if tok.tokTy != cIdentifier || tok.lexeme != "let" {
		return "", errors.New("not a let clause")
	}

	tp.advance(1)

	tok = tp.ctoken()

	v, err := tp.variable()

	if err != nil {
		return "", err
	}

	tp.advance(1)
	varname := tok.lexeme

	code := v
	code += "\n"

	tok = tp.ctoken()
	if tok.tokTy != cIdentifier || tok.lexeme != "in" {
		return "", errors.New("not a let clause: no in")
	}

	tp.advance(1)

	out, err := tp.code(cEnd, "", tp.ret)
	if err != nil {
		return "", err
	}
	code += out

	code += "del " + varname
	code += "\n"
	return code, nil
}

func (tp *Transpiler) index() (string, error) {
	// (id|list) ":" expr
	var output string = ""
	var literal string
	tok := tp.ctoken()

	if tok.tokTy != cIdentifier {
		list, err := tp.list()

		if err != nil {
			return "", errors.New("not an index expr: no list or identifier")
		}

		literal = list
	} else {
		literal = tok.lexeme
	}

	output += literal

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cColon {
		return "", errors.New("not an index expr: no colon")
	}

	tp.advance(1)
	tok = tp.ctoken()

	expr, err := tp.expr()
	if err != nil {
		return "", errors.New("not an index expr: error parsing expr")
	}

	output += "[" + expr + "]"

	return output, nil
}

func (tp *Transpiler) class() (string, error) {
	// "=" id "(" code ")"
	var name string
	var fields []string

	tok := tp.ctoken()

	if tok.tokTy != cEq {
		return "", errors.New("not a class: no =")
	}

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cIdentifier {
		return "", errors.New("not a class: no identifier")
	}
	name = tok.lexeme

	tp.advance(1)
	tok = tp.ctoken()

	if tok.tokTy != cLparen {
		return "", errors.New("not a class: no '('")
	}

	tp.advance(1)
	tok = tp.ctoken()

	for true {
		if tok.tokTy == cRparen || tok.tokTy == cEOF {
			break
		}

		if tok.tokTy != cIdentifier {
			return "", errors.New("not a class: no identifier")
		}

		fields = append(fields, tok.lexeme)

		tp.advance(1)
		tok = tp.ctoken()
	}

	if tok.tokTy != cRparen {
		return "", errors.New("not a class: unexpected EOF")
	}

	list := ""

	for i := range fields {
		list += fields[i]

		if i < len(fields)-1 {
			list += ","
		}
	}

	output := "class " + name + ":\n"
	ident++
	output += strings.Repeat("\t", ident)
	output += "def __init__(self," + list + "):\n"
	ident++

	for i := range fields {
		output += strings.Repeat("\t", ident)
		output += "self." + fields[i] + "=" + fields[i] + "\n"
	}

	ident -= 2

	output += "\n"

	return output, nil
}

func (tp *Transpiler) match() (string, error) {
	var output string
	var matchd string

	tok := tp.ctoken()

	if tok.tokTy != cIdentifier || tok.lexeme != "match" {
		return "", errors.New("not a match statement: no 'match'")
	}

	tp.advance(1)
	tok = tp.ctoken()

	matchd, err := tp.expr()

	if err != nil {
		return "", errors.New("not a match statement: error parsing expression to be matched")
	}

	output += "__pfn___matchd__ = " + matchd + "\n"

	tp.advance(1)
	tok = tp.ctoken()

	prefix := ""

	for true {
		tok = tp.ctoken()

		if tok.tokTy == cEnd {
			break
		}

		if tok.tokTy == cEOF {
			return "", errors.New("not a match statement: expected 'end', got 'EOF'")
		}

		if tok.tokTy != cDol {
			return "", errors.New("not a match statement: invalid match expression")
		}

		tp.advance(1)

		expr, err := tp.expr()

		if err != nil {
			return "", errors.New("not a match statement: error parsing match")
		}

		output += prefix + "if __pfn___matchd__ == " + expr + ":\n"

		tp.advance(1)
		tok = tp.ctoken()

		if tok.tokTy != cLparen {
			return "", errors.New("not a match statement: missing match body")
		}

		tp.advance(1)

		ident++
		code, err := tp.code(cRparen, "", tp.brk)
		ident--

		if err != nil {
			return "", errors.New("on match: error parsing match body")
		}

		output += code

		tp.advance(1)

		prefix = "el"
	}

	output += "\ndel __pfn___matchd__"

	return output, nil
}

// dangerous language constructs

func (tp *Transpiler) out() (string, error) {
	tok := tp.ctoken()

	if tok.tokTy != cIdentifier || tok.lexeme != "out!" {
		return "", errors.New("not an out statement: no 'out!'")
	}

	tp.advance(1)

	code, err := tp.code(cEnd, "")
	if err != nil {
		return "", err
	}

	tp.Output = code + "\n" + tp.Output

	return "", nil
}

// utils

func (tp *Transpiler) advance(n uint) {
	if tp.current+n < uint(len(tp.tokens)) {
		tp.current += n
	}
}

func (tp *Transpiler) previous(n uint) {
	if tp.current >= n {
		tp.current -= n
	}
}

func (tp Transpiler) ctoken() Token {
	return tp.tokens[tp.current]

}

func (tp Transpiler) err(where string, msg string) {
	//if !haderror {
	//haderror = true
	tok := tp.ctoken()

	heading := "========================================="
	red := "\033[1;31m"
	normal := "\033[0m"
	cerr := ""

	for i := range cerrs {
		cerr += cerrs[i] + "\n"
	}

	log.Fatalf("%shad error on %s, line %d\n%s%s\n%s%s\n%s%s%s\n",
		cerr, where, tok.line+1, red, heading, normal, msg, red, heading, normal)
	//}
}

func (tp Transpiler) lerr(where string, msg string) {
	//if !haderror {
	//haderror = true
	tok := tp.ctoken()

	heading := "========================================="
	yellow := "\033[1;33m"
	normal := "\033[0m"
	cerr := ""

	for i := range cerrs {
		cerr += cerrs[i] + "\n"
	}

	fmt.Printf("%shad error on %s.\nyou can probably ignore this error safely, as it was not called from rfwo\nthe caller may not be aware of pfns like return, for example.\nline %d\n%s%s\n%s%s\n%s%s%s\n",
		cerr, where, tok.line+1, yellow, heading, normal, msg, yellow, heading, normal)
	//}
}

func (tp *Transpiler) findMatchingParserFn(fns []parserFn) (string, error) {
	/*
		Return First Working One

		returns the first matching
		parsing function on the given
		list
	*/

	old := tp.current

	/*
		couldn't think of a better name, 'max' is used for
		storing the parser function that has taken the most steps,
		it is used for setting 'probableCause' later.
	*/
	var max uint
	var probableCause string
	var tokenAtErr string

	for i := range fns {
		res, err := fns[i]()

		if err == nil {
			return res, nil
		}

		steps := tp.current - old
		if steps >= max {
			max = steps
			probableCause = err.Error()
			tokenAtErr = tp.ctoken().lexeme
		}

		tp.current = old
	}

	tp.err("findMatchingParserFn", "no matching pfn for tokens '"+tp.ctoken().lexeme+"' through '"+tokenAtErr+"'\nprobably because of this error: "+probableCause)
	return "", errors.New("no matching pfn")
}

func (tp *Transpiler) rm() {
	tp.tokens = append(tp.tokens[:tp.current], tp.tokens[tp.current+1:]...)
}
